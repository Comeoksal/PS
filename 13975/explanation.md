## 문제
![](https://velog.velcdn.com/images/keumsiun0503/post/b54daff5-ca42-4081-83dc-a80b80dbfda0/image.png)
https://www.acmicpc.net/problem/13975

### 문제 설명
>
1. 소설을 여러 장(chapter)로 나누어 쓰고, 각 장을 두 개씩 합쳐 나가며 최종적으로 한 소설을 만든다.
2. 두 개의 장을 합칠 때, 각 장의 크기의 합만큼 비용이 든다.
3. 예를 들어 C1, C2, C3, C4 네 개의 장의 크기는 40, 30, 30, 50이라고 할 때, C2 + C3 = X1 **60**의 비용이 든다. 다음으로 C1 + X1 = X2 **100**의 비용, X2 + C4 = **150**의 비용. 따라서 총 비용은 **310**이 된다. 하지만 더 효율적인 방법도 있다.
4. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 **70+80+150=300** 이다.
5. 이런 방식으로 두 장씩 합쳐가며 한 소설을 완성할 때, 최소 비용을 출력
- 조건 1: 프로그램 입력은 총 T개의 테스트 데이터로 이루어짐
- 조건 2: 소설을 구성하는 장의 수 K는 3<=K<=1,000,000
- 조건 3: 파일의 크기<=10,000

📖**테스트 케이스 살펴보기**
![](https://velog.velcdn.com/images/keumsiun0503/post/b72381cd-e777-45c3-97aa-5b3834e79512/image.png)

첫째 줄에 T==2개인 테스트 데이터 수가 주어지고, 총 2번의 최소 비교 횟수를 출력하는 것을 볼 수 있다.
- 첫번째 데이터의 경우
문제의 예시처럼 각 장 C1, C2, C3, C4가 40 30 30 50의 크기로 주어졌고, 최소 비교 횟수가 300인 것을 알 수 있다.
- 두번째 데이터의 경우
15개의 장이 주어지고, 어떻게 최소 비교 횟수가 826인지는 이제 우리가 풀어야한다.

해당 문제를 풀기 위해서는 **최소 비교 횟수**의 개념을 잘 이해해야 하는데,
수열이 주어지고, 두 개씩 더해서 결과값이 나왔을 때, 결과 값들의 합에 최소를 만들어 내기 위해선 **최소값**들 끼리 더해줘야 한다.

예를 들어 1, 2, 100이 있을 때,
1 + 100 = 101
101 + 2 = 103
결과 : 101 + 103 = 206 와 같이 처음부터 큰 값을 더해주게 되면 이가 다음 결과에 영향을 미쳐서 값이 커진다. 따라서
1 + 2 =3
3 + 100 = 103
결과 3 + 103 = 106 과 같이 최소값들 끼리 계속 더해줘야 최종 결과값이 커지지 않는다.
🔽참고 문제
https://velog.io/@keumsiun0503/%EB%B0%B1%EC%A4%80BOJ-1715%EB%B2%88-%EC%B9%B4%EB%93%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0-JAVA%EC%9E%90%EB%B0%94

💡**그리디와 우선순위큐**
- **그리디**
그리디는 각 단계에서 욕심내어 값을 취할 수 있는만큼 취하여 **지역 최적해**를 찾는다.
각 단계의 해를 모아 **최적 해의 근사값**을 구한다.
- **우선순위큐**
큐는 기본적으로 선입선출인 자료구조이다.
우선순위큐는 데이터에 우선순위를 두고, 우선순위가 높은 데이터부터 내보낸다.

🔥**활용하기**
T개의 테스트 데이터에 대해서(로직은 동일하기 때문에 T번 반복하면 됨)
1. 각 장의 크기를 입력 받음
2. 크기가 낮은 장부터 나오는 **우선순위큐**에 삽입
3. **그리디** 알고리즘을 통해서 해당 단계에서의 **최소 비교 횟수**를 구하고, 결과 값에 저장, **다시 우선순위큐**에 삽입
3번 과정을 우선순위 큐에 값이 하나 남을 때까지 하면 모두 비교한 것이 된다.
⚠️**주의할 점**
문제의 조건 2, 3에 의하면 각 장을 합치다보면 결과값이 **Intger**자료형의 범위인 -21억~21억을 넘어가는 경우가 발생한다.
따라서 결과값을 **Long** 자료형으로 선언하여 -922경~922경 범위까지 허용해줘야 한다.

### 문제 풀이 설계
>
1. 테스트 데이터의 수 **T** 입력 받기(T번 반복)
2. 각 장의 수 **K** 입력 받기, 각 장을 입력 받아 크기가 낮은 데이터가 먼저 나오는 **우선순위큐**에 삽입.
3. 우선순위큐에 데이터가 한 개 남을때까지 다음 과정을 반복
3-1. 우선순위큐로부터 두 장의 크기를 꺼내 더하고, 결과값에 더하기, 다시 결과값을 우선순위 큐에 삽입.
4. 결과값을 출력, 우선순위큐 내부 데이터를 삭제(남은 테스트 데이터에 사용해야하므로).

## 문제 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    static int T, K;
    static PriorityQueue<Long> pq = new PriorityQueue<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        //1. 테스트 데이터 수 T
        T = Integer.parseInt(br.readLine());

        while(T-->0){
            //2. 각 장의 수 K와 각 장의 크기를 우선순위 큐에 삽입
            K = Integer.parseInt(br.readLine());
            long result = 0;
            StringTokenizer st = new StringTokenizer(br.readLine());
            while(K-->0){
                pq.add(Long.parseLong(st.nextToken()));
            }
            //3. 우선순위 큐의 데이터가 한 개 남을때까지 반복
            while(pq.size()!=1){
                Long X = pq.poll() + pq.poll();
                result+=X;
                pq.add(X);
            }
            //4. 결과값 출력, 우선순위 큐 내부 데이터 삭제(남은 테스트 데이터에 사용해야하므로)
            sb.append(result).append('\n');
            pq.clear();
        }
        br.close();
        System.out.print(sb.toString());
    }
}
```
![](https://velog.velcdn.com/images/keumsiun0503/post/284bf7fb-9d61-487d-af5d-b7bf3e9c618f/image.png)
### 느낀점
>
비슷한 유형의 PS 문제를 풀면서 유형을 익히는 것도 중요한 것 같다. 문제의 로직이 이해가 안 되면 이해를 해야하지만, 이해가 된다면 암기가 아닌 공부가 된 것이므로 반복 이해와 반복 학습을 통한 공부를 계속해야겠다.
