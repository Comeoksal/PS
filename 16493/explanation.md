## 문제

![](https://velog.velcdn.com/images/keumsiun0503/post/4fc7573f-6048-476d-8a96-e4404ab27caa/image.png)
https://www.acmicpc.net/problem/16493

### 문제 설명
>
1. 철수는 책을 빌리고, 남은 기간 동안 최대한 많은 페이지를 읽고 싶어함.
2. 책은 여러 챕터로 구성되어 있고, 각 챕터는 독립적이기에 어느 챕터를 읽기 위해 다른 챕터를 읽어야 할 필요가 없음(아무 챕터를 골라서 읽으면 됨)
3. 각 챕터마다 페이지 수가 다르고, 한 챕터를 읽는다면, 그 챕터에 해당하는 페이지는 모두 읽어야 함.
4. 각 챕터마다 읽는 데에 걸리는 시간이 주어진다면(페이지 수와 상관없음), 남은 기간 N일 동안 읽을 수 있는 최대 페이지 수를 출력

![](https://velog.velcdn.com/images/keumsiun0503/post/5b59da49-f914-4087-8b93-bf41438e8e26/image.png)

>예제 입력1에서 첫 줄의 7 7은 남은 기간 N, 챕터의 수 M다
둘째 줄부터 각 챕터를 읽는 데에 걸리는 시간(3)과 해당 챕터의 페이지 수(10)가 주어진다.

문제는 단순한데, 효율이 좋은 챕터(읽는 데에 걸리는 시간이 짧고, 페이지 수는 많은 챕터)를 골라서 읽어야 하는 문제이다. 하지만 경우의 수가 많아지면 어떤 것이 효율이 좋은 것인지 알 수 없기 때문에, 
**챕터를 하나씩 고려하며, 해당 챕터에 대해서 활용할 수 있는 일 수에 최대로 읽을 수 있는 페이지 수를 구해야 한다.**
위와 같은 방식을 접하면 떠올릴 수 있는 알고리즘은 
💡**DP(Dynamic Programming) 알고리즘, 동적 계획 기법**
큰 문제를 작은 부분 문제들로 나누고, 부분 문제들의 해를 활용하여 더 큰 부분 문제들을 해결하고, 최종 해에 도달하는 방식
✅큰 문제 : N일간 읽을 수 있는 최대 페이지 수
✅작은 부분 문제 : i번째 챕터만 고려하여 N일간 읽었을 때 각 일 수(1일,2일,3일..)를 활용하여 읽을 수 있는 최대 페이지 수

💡이 문제의 예제 입력2를 예시로 DP 알고리즘을 적용시켜보자.

1. 남은 기간은 5일, 총 챕터 수는 3개이다.
2. 각 챕터마다 총 사용한 일 수에 대하여 읽은 페이지 수를 저장하는 dp 2차원 배열을 만든다. dp[i][j].
(**dp[1][1]은 1번 챕터가 1일을 활용할 때 읽은 페이지 수를 의미. 값은 0**)
(**dp[1][2]는 1번 챕터가 2일을 활용할 때 읽은 페이지 수를 의미. 값은 100**)
(**dp[1][3]은 1번 챕터가 3일을 활용할 때 읽은 페이지 수를 의미. 값은 똑같이 100**)
3. 위와 같은 방식으로 동적으로 dp배열에 값을 채워나가며 진행하는데, 할당 조건은 다음과 같다.
- 만약 i번째 챕터를 j일 수만큼 읽고도 활용할 수 있는 일 수가 남아있다면, 
**i번째 챕터를 읽었을 때 읽는 페이지수 + dp[i-1][남는 일 수] 값과**, 
**dp[i-1][j]** (i번째 챕터를 고려하기 전에 j일 수만큼 활용했을 시 읽을 수 있는 페이지 수의 최대값)값
두 개를 비교하여 더 큰 값을 저장
- 만약 i번째 챕터를 j일 수만큼 읽었을 때 활용할 수 있는 남은 일 수가 없다면,
**dp[i-1][j]값** (i번째 챕터를 고려하기 전에 j일 수만큼 활용했을 시 읽을 수 있는 페이지 수의 최대값) 저장

4.이런 방식을 모든 챕터에 대하여(순서 상관 없음) 진행해서 남은 기간 동안 읽을 수 있는 최대 페이지 수를 구할 수 있다 (**dp[3][5] 3번 챕터까지 고려하여 최대 일 수만큼 활용했을 때 읽는 페이지 수가 해가 됨**)

### 문제 풀이 설계
>
1. 남은 기간 N, 총 챕터 수 M을 입력 받음
2. i번째 챕터를 읽는 데에 걸리는 일 수(book[i][0])와, 
챕터를 읽으면 읽게되는 페이지 수(book[i][1])를 
book[M+1][2] 2차원 배열에 저장 (첫번째부터 시작할 것이기 때문에 M+1만큼의 행 크기를 잡음)
3. i번째 챕터를 j일 수만큼 활용했을 때, 읽게되는 페이지수를 저장할 dp[i][j] 2차원 배열 정의(크기는 dp[M+1][N+1], 첫번째부터 시작할 것이기 때문에 M+1, N일까지 읽을 수 있으므로 N+1까지 크기 지정)
4. 2중 반복문을 통해서 i번째 챕터일 때, j일 수만큼 활용하면 읽게되는 페이지 수를 dp 배열에 저장, 이때 조건은 다음과 같음
- 만약 i번째 챕터를 j일 수만큼 읽고도 활용할 수 있는 일 수가 남아있다면**(j-book[i][0]>=0, 해당 챕터를 읽었다는 전제이므로 0도 포함)**, 
1. **i번째 챕터를 읽었을 때 읽는 페이지수 book[i][1] + dp[i-1][남는 일 수] 값과**, 
2. **dp[i-1][j]값** (i번째 챕터를 고려하기 전에 j일 수만큼 활용했을 시 읽을 수 있는 페이지 수의 최대값)
🔥두 개를 비교하여 더 큰 값을 저장
- 만약 i번째 챕터를 j일 수만큼 읽었을 때 활용할 수 있는 남은 일 수가 없다면,
**dp[i-1][j]값** (i번째 챕터를 고려하기 전에 j일 수만큼 활용했을 시 읽을 수 있는 페이지 수의 최대값) 저장
5. 마지막 챕터 M번째까지 고려해서 남은 기간 N일을 최대로 활용했을 때 읽을 수 있는 페이지 수
**dp[M][N]값 출력**

## 문제 풀이

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        //1. 남은 기간 N, 총 챕터 수 M
        st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        //2. i번째 챕터를 읽는 데에 걸리는 일 수(book[i][0]), 
        // i번째 챕터를 읽으면 읽게되는 페이지 수(book[i][1])를 저장할 배열
        int[][] book = new int[M+1][2];
        for(int i=1; i<=M; i++){
            st = new StringTokenizer(br.readLine());
            book[i][0] = Integer.parseInt(st.nextToken());
            book[i][1] = Integer.parseInt(st.nextToken());
        }
        //3. i번째 챕터를 j일 수마늠 활용했을 때, 읽게되는 페이지 수를 dp[i][j]에 저장
        int[][] dp = new int[M+1][N+1];
        //4. 조건에 따라서 동적으로 dp값을 저장하고, 이를 활용하여 다음 dp값 구하기
        for(int i=1; i<=M; i++){
            for(int j=1; j<=N; j++){
                if(j-book[i][0]>=0){
                    dp[i][j] = Integer.max(book[i][1]+dp[i-1][j-book[i][0]], dp[i-1][j]);
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        //5. 마지막 챕터 M번째까지 고려해서 남은 기간 N일을 최대로 활용했을 때 읽을 수 있는 페이지 수 출력
        System.out.println(dp[M][N]);
    }
}
```
![](https://velog.velcdn.com/images/keumsiun0503/post/4b54c27c-38c7-45af-a0e0-4cd5c386d16e/image.png)
### 느낀점
>
DP개념을 이해하고, 문제를 봤을 때 풀이 방식이 머리에서 잘 그려졌다. 여러 DP 문제들을 섞어가며 풀어주면서 DP방식을 활용해야 될 때를 잘 판단하고 싶다. 실제로 기업 입사 코딩테스트를 치게 되면, 백준에서 문제 풀 때와는 다르게 어떤 알고리즘을 사용해야 될지 몰라서 못 푸는 경우가 많다고 한다. 문제를 접했을 때, 바로 아이디어를 떠올릴 수 있게 다양한 문제를 풀어봐야겠다.
