## 문제
![](https://velog.velcdn.com/images/keumsiun0503/post/ee74a20b-aca6-420c-a42e-447a33444d66/image.png)
https://www.acmicpc.net/problem/1715
### 문제 설명
>
1. 정렬된 숫자 카드 묶음들이 있다.
2. 두 묶음을 하나로 합치려면, 두 묶음의 숫자 카드의 수만큼 비교를 해야한다. (20장과 30장 묶음을 합쳐서 정렬하려면 50번의 비교가 필요)
3. 숫자 카드 묶음들이 주어졌을 때, 두 묶음씩 골라서 합쳐나가면 고르는 순서에 따라 비교 횟수가 달라진다. 
(10, 20, 40장 묶음이 있을 시 (10+20) + (30+40) = 100, 
그러나 (10+40) + (50+20) = 120번을 비교해야하므로 비효율적이다.) 
4. N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소 몇 번의 비교가 필요한지 출력
- 조건 1: 1<=N<=100,000 , 각 숫자 카드 묶음의 크기는 1000보다 작거나 같은 양의 정수

📖**테스트 케이스 살펴보기**
![](https://velog.velcdn.com/images/keumsiun0503/post/9177efdb-4cd9-4d39-8392-29b4e68e7e6b/image.png)

- 예제 입력 1번
숫자 카드 묶음 (10장, 20장, 40장)
1. 10장 + 20장 = **30**번 비교
2. **30**장 + 40장 = **70**번 비교
최소 비교 횟수 **30 + 70 = 100**

어떤 숫자 카드 묶음을 고르는지 순서는 상관 없기 때문에
전체 숫자 카드 묶음들 중에서 **최소 크기들 두 묶음끼리 합쳐서 더하면 최소 비교 횟수를 가지게 됨**

💡**그리디와 우선순위 큐**
- **그리디**
각 단계마다 **지역 최적해**를 찾는 방식.
각 단계마다 최대한 **욕심내어 취할 수 있는 만큼 값을 취하고**,
각 단계의 **해를 모아 최적 해의 근사 값을 구함**.
- **우선순위큐**
큐는 기본적으로 선입선출의 자료구조임.
하지만 우선순위큐는 **우선순위가 높은** 자료부터 먼저 나가는 자료구조.
우선순위큐를 잘 활용하기 위해서는 자료들에 **원하는 우선순위**를 잘 부여해줘야함.

🔥**활용하기**
1. N개의 카드 묶음을 받으면 **낮은 크기가 먼저 나오는 우선순위큐에 삽입**
2. **그리디** 알고리즘을 통해서 각 단계에서의 최적해 (가장 낮은 값 두 개의 합)를 구해서 
다시 **우선순위 큐**에 삽입
2번 과정을 반복하여 **현재 카드 묶음들 중 최소 비교 횟수를 가지는 두 카드 묶음과, 두 카드 묶음의 비교 횟수**를 얻을 수 있음
⚠️**주의할 점**
만약 N==1인 C크기의 카드 묶음 한 개라면 무엇을 출력해야 할까?
정답은 0. (C가 아님)
**목표는 비교 횟수를 출력하는 것인데, 카드 묶음이 1개라면 비교 횟수가 0이기 때문!**

### 문제 풀이 설계
>
1. 카드 묶음들의 수 **N** 입력 받기.
2. 카드 묶음의 각 크기들을 **크기가 낮은 순서부터 나오는 우선순위큐**에 삽입
3. 만약 N!=1이라면, 다음 과정을 수행
3-1. 우선순위 큐 내부에 값이 1개가 남을 때까지 ()속 과정 반복.
(큐에서 숫자 2개를 꺼내어 더하고(비교 횟수를 구하고), 결과값에 더하기, 결과값을 큐에 삽입.)
3-2. 결과값을 출력
4. ⚠️만약 N==1이라면, 0을 출력

## 문제 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //1. 카드 묶음들의 수 N
        int N = Integer.parseInt(br.readLine());
        //2. 카드 묶음의 각 크기 우선순위 큐에 삽입
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int i=0; i<N; i++){
            pq.add(Integer.parseInt(br.readLine()));
        }
        //3. N의 조건에 따라 다음 과정 수행
        if(N!=1){
            int result = 0;
            //3-1. 우선순위 큐에 값이 1개 남을 때까지 카드 묶음 두 개씩 비교.
            while(pq.size()!=1){
                int X = pq.poll() + pq.poll();
                result+=X;
                pq.add(X);
            }
            System.out.println(result);
        } 
        //4. N==1이라면, 0 출력
        else {
            System.out.println(0);
        }
    }
}
```
![](https://velog.velcdn.com/images/keumsiun0503/post/be010fce-6cc1-406e-b894-17f2cd4a2ea2/image.png)
### 느낀점
>
그리디적인 요소 보다는 우선순위 큐의 개념과, 문제 속 "최소 비교"를 하는 방법만 떠올린다면 골드 하위 문제치고는 쉽게 풀 수 있는 문제이다. 
우선순위큐, 해시테이블과 같은 유용한 자료 구조를 잘 활용해야겠다고 많이 느꼈다.