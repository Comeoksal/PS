## 문제

![](https://velog.velcdn.com/images/keumsiun0503/post/bba961c0-c023-4f51-9f12-fc422163259f/image.png)
https://www.acmicpc.net/problem/11047

### 문제 설명
>
1. 가지고 있는 동전의 종류 N, 동전들을 합하여 만들 금액 K가 주어짐.
2. N개의 동전의 종류가 주어지고(10, 50, 100 ...) 이 동전들을 조합하여 금액 K를 만들어낼 때, 동전들의 개수 **최솟값** 출력.
3. 기본적인 **그리디(탐욕)** 문제인데.. 그리디란?

- 주어진 문제에서 최적의 해를 구하는 데에 사용되는 근사적인 방법 중 하나
- 여러가지 경우 중 하나를 선택해야 할 때, 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
- 하지만 항상 최적의 값을 구하는 것이 아니기 때문에, 최적의 값에 **근사한 값**을 구하는 방식

예를 들어서 2760원을 가지고, 이를 500원, 100원, 50원, 10원 동전으로 나눌 때, 동전의 개수가 최소가 되게 하려면 어떻게 해야할까?
-> 2760원을 모두 10원짜리로 만든다면 동전이 276개나 필요하므로 이는 적절한 방식이 아니게 된다. 그렇다면 동전의 개수가 최소가 되게 하기 위해서 금액이 높은 동전부터 **나눌 수 있는만큼** 먼저 선택하여 나누게 된다면 동전의 개수가 최소가 된다. 이러한 방식을 **그리디 알고리즘**이라고 한다. (굉장히 단순함)

그렇다면 왜 최적의 값에 **근사한 값**을 구하는 방식인 걸까?
->만약 200원을 가지고, 이를 100원, 10원 동전으로 나눈다고 생각해보자. 그렇다면 위에서 설명한 그리디 알고리즘에 따라서 **100원 2개**가 해가 될 것이다. 하지만 160원 동전이 있다고 가정한다면 어떻게 될까?
알고리즘에 따라서 160원 동전을 100원 동전보다 먼저 선택할 것이고, **160원 동전 1개, 10원 동전 4개**가 해가 될 것이고, 이는 최적의 해가 아니다.*(최적의 해는 100원 2개이기 때문)*
이러한 이유로 그리디 알고리즘만으로는 최종 해가 최적 해가 될 수는 없다.

그럼에도 그리디 알고리즘이 사용되는 이유(장점)는 다음과 같다
- 빠른 수행 속도(시간 복잡도 낮음)
- 구현이 간단함
- 문제의 조건에 따라서 최적해를 구하기도 함

### 문제 풀이 설계
>
1. 가지고 있는 동전의 종류 N, 만들어야 할 금액 K를 입력 받음
2. 각 종류의 동전 금액을 N줄 입력 받는데, 문제의 조건 (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)에 따라서 최적의 해를 구할 수 있게 됨.
3. 각 동전 금액을 배열에 넣고 역으로 그리디 알고리즘을 거쳐도 되지만, 오름차순으로 입력 받으므로, 스택에 저장했다가 높은 금액부터 **그리디 알고리즘** 적용
3-1. 만약 다음 금액으로 나눌 수 없다면, 스택에서 다음 동전을 꺼내서 선택
3-2. 만약 다음 금액으로 나누어진다면 **나눌 수 있는 만큼** 나누고 몫을 저장
4. 금액이 0원이 되면 알고리즘 종료

## 문제 풀이

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        //1. 동전의 종류 N, 만들 금액 K 입력 받음
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        Stack<Integer> coins = new Stack<>();
        //2,3. 각 종류의 동전을 입력 받음, 스택에 저장하여 높은 금액부터 그리디 알고리즘 적용
        for(int i=0; i<N; i++){
            coins.push(Integer.parseInt(br.readLine()));
        }

        int result = 0;
        //4. 금액이 0원이 되면 알고리즘 종료 (A1 = 1이기 때문에 스택이 비었을 경우를 생각 안 해도 됨.)
        while(K!=0){
            int coin = coins.pop();
            //3-1,2. 금액으로 나눌 수 있다면 나눌 수 있는 만큼 나누고 몫을 저장. 그렇지 않다면 다음 동전으로로
            if((K/coin)>=1){
                result += K/coin;
                K%=coin;
            }
        }
        System.out.println(result);
    }
}
```
![](https://velog.velcdn.com/images/keumsiun0503/post/ec871263-8d35-4784-a7d4-d5f8af61c208/image.png)

### 느낀점
>
그리디 알고리즘은 이론은 단순하지만 중요한 알고리즘인 것 같다. 그리디 알고리즘을 적용하는 문제의 표준이라고 할 수 있는 동전 거스름돈 문제를 풀어보았는데, 단순히 알고리즘을 공부하고 푸는 것과, 설명을 할 수 있을 정도로 공부하고 푸는 것은 큰 차이가 있음을 느꼈다. 다양한 그리디 알고리즘 문제를 풀어봐야겠다.

