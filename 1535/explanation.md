## 문제

![](https://velog.velcdn.com/images/keumsiun0503/post/7c075259-1292-4923-9385-58512f590069/image.png)
https://www.acmicpc.net/problem/1535

### 문제 설명
>
1. 세준이가 인사할 사람은 총 N명이다.
2. 세준이는 i번째 사람한테 인사할 때마다 L[i]만큼의 체력을 잃고, J[i]만큼의 기쁨을 얻는다.(각각의 사람에게 최대 1번만 인사 가능)
3. 세준이의 체력은 100이며, 기쁨은 0인 상태에서 시작한다. 만약 체력이 0이하면 죽어서 아무런 기쁨을 못 느끼게 된다.
4. 세준이가 체력이 모두 소진되지 않는 선에서 얻을 수 있는 최대 기쁨을 출력.

재미있는 문제인 것 같다.
우선 세준이는 1번부터 N번째까지 사람들이 한 명씩 들어오는데, 인사를 할 수도 있고, 안 할 수도 있다. 그렇다면 모든 사람에 대해서 정해진 체력 내에서 얻을 수 있는 기쁨을 알아내야 한다. 그러므로 해당 문제는 DP(Dynamic Programming) 알고리즘을 사용해야 한다.
![](https://velog.velcdn.com/images/keumsiun0503/post/6e011342-e372-4dfb-bd51-6c5a1a22cf4d/image.png)
테스트 케이스를 보면, 문제 풀이 방식을 생각해볼 수 있다.
- 예제 입력 1번에서, 3은 사람의 수. 
1, 21, 79는 첫번째 사람~세번째 사람까지 인사를 하면 깎이는 체력
20, 30, 25는 첫번째 사람~세번째 사람까지 인사를 하면 얻는 기쁨이다.
예를 들어 1번 사람한테 인사를 하면 1의 체력이 소진되고, 20의 기쁨을 얻게 된다.

문제의 조건은 **체력이 모두 소진되지 않는 선에서 얻을 수 있는 최대 기쁨**이고, 각 사람들에게 인사를 할 시에 소진되는 체력은 정해져있다.
(**기쁨을 많이 주더라도 체력을 많이 깎는 사람이 있을 수 있다.** 그런 사람은 기쁨을 적당히 주는 다른 여러명의 사람보다 효율이 안 좋을 수 있음. 예를 들어 80의 기쁨을 주지만 체력을 99깎는 사람보다, 40, 50의 기쁨을 주지만 체력을 10, 20깎는 사람들만 골라서 인사하는 것이 효율적이기 때문에 한 사람씩 경우의 수를 생각해줘야함.)
💡DP 동적 계획 기법이란
- **하나의 큰 문제를 여러 개의 작은 문제들로 나누어 그 결과를 저장하고, 이를 활용하여 큰 문제를 해결하는 방식**이다.
DP방식을 이해하는 데에 좋은 문제 : 9095번 : 1, 2, 3 더하기 https://www.acmicpc.net/problem/9095

DP알고리즘의 특징은, 작은 문제들의 값을 구하는데에 작은 문제의 값을 이용하고, 이를 활용하여 큰 문제를 해결하는 것이다. 그리고 이후에 활용할 작은 문제의 값을 계속해서 구해나가면서 문제를 푼다.
DP방식은 처음 접하면 복잡해서 무슨 얘기인지 이해하기 어려울 수 있다. 이번 문제를 예로 들면서 어떤 방식을 채택하는지 설명해보겠다.

1. i 번째 사람에게 인사하면 소진되는 체력을 **person[i][0]**, 얻는 기쁨을 **person[i][1]**에 저장한다.
2. **각 체력에 대하여 2차원 dp배열 dp[N+1][100]을 생성(N은 사람의 수)** 
dp배열은 각 체력에 대해서 해당 사람에게 인사할 때 얻는 기쁨의 최대치를 저장할 값이다. 
(예를 들어 인사하면 소진되는 체력이 26, 얻는 기쁨이 56인 사람이 1번째 사람이라고 가정)
**🔥dp[1][0] 값은 1번째 사람에게 체력이 0 소진된 상태에서 얻을 수 있는 기쁨값**이 저장된 것이다. 그렇다면 값은 0. (dp[][[k] 에 k번째 인덱스는 k만큼의 체력을 의미함)
dp[1][26]값은 어떻게 될까? 17을 소진한다면 기쁨을 56얻을 수 있다.
따라서 dp[1][27] = 56이다. 이런 방식으로 dp[1]28, 29, ..., 99까지 모두 56이 저장되는 것이다.
3. 또한 이를 2번째 사람의 dp[2][] 값을 저장할 때 활용한다. 
(2번 째 사람은 체력을 13 소진하고, 기쁨을 21준다고 가정)
3-1. 만약 해당 체력값 50에서(ex dp[2][50]) 
2번째 사람에게 인사하고 소진되는 체력을 제외하고도 체력이 남거나 0이라면(50-13=37만큼 남음), 
그만큼 1번째 사람에게도 인사하고, 기쁨값을 더한다**(person[2][1](2번째 사람에게 인사하면 얻는 기쁨값)+dp[1][37])**. 
그렇게 하여 나온 값과 이전 dp값(dp[1][50])을 비교하여 더 큰 값을 dp에 저장. 
3-2. 만약 체력이 남지  않는다면(0 미만, 예를 들어 12인 경우) 이전 dp값(dp[1][12]) 값을 dp[2][12]에 저장한다
4. 이런 방식을 모든 사람에게 적용하여, 이전 dp값을 활용하여 모든 사람에게 인사했을 때, 해당 체력값을 소진한 데에서 얻을 수 있는 최대의 기쁨을 dp에 저장해 나가고, dp[N][99] (마지막 사람일 때 체력을 최대로 소진한 경우) 가 큰 문제에 대한 해가 될 것이다.

**설명이 잘 됐을지 모르겠다. 이해가 안 된다면 문제 풀이 설계로**

### 문제 풀이 설계
>
1. 인사할 사람의 수 N을 입력 받음
2. 각 사람에 대하여 인사하면 소진되는 체력(person[i][0]), 인사하면 얻는 기쁨(person[i][1]) 을 저장할 person 2차원 배열 정의하고 값을 입력 받음.
3. i번째 사람에 대하여 j의 체력이 소진된 상태에서 얻을 수 있는 기쁨값을 저장할 dp 배열 dp[i][j]를 선언. (i는 사람의 순서이므로 N+1이 될 것이고, j는 100)(자바의 배열 기본값 설정에 의해서 dp[0][0~99]값은 모두 0이 할당됨)
4. 2중 반복문을 통해서 첫번째 사람부터 (순서는 상관없음) 모든 사람을 검사한다.
이때 각 체력에 대하여(0~99) dp배열에 값을 저장하는데, 조건은 다음과 같다.
4-1. 만약 i번째 사람에 대하여 해당 사람에게 인사하면 소진되는 체력(person[i][0])값이 해당 체력 j값보다 작거나 같다면 인사를 하고도 체력이 남으므로 남는 값만큼 이전 dp배열에서 값을 더한다.(person[i][1] + dp[i-1][남는값])
그리고 이를 이전 dp값(i번째 사람을 검사하기 이전에 해당 체력에서 얻는 최대 기쁨값 dp[i-1][j])과 비교하여 더 큰 값을 dp[i][j]에 저장
4-2. 만약 i번째 사람에 대하여 해당 사람에게 인사하면 소진되는 체력(person[i][0])값이 해당 체력 j값보다 크다면(i번째 사람에게는 j체력을 소진해서는 얻을 수 있는 기쁨이 없음을 의미), 이전 dp값(dp[i-1][j])을 dp[i][j]에 저장한다.
5. 마지막 사람까지 인사했을 경우 소진할 수 있는 체력 최대값 99를 소진해서 얻을 수 있는 기쁨값(dp[N][99])을 출력

## 문제 풀이

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //1. 인사할 사람의 수 N 입력 받기
        int N = Integer.parseInt(br.readLine());
        //2. person 배열 (1번째부터 시작하기 위해서 N+1로 설정) 선언언 및 값 할당받기
        int[][] person = new int [N+1][2];
        StringTokenizer st;
        st = new StringTokenizer(br.readLine());
        for(int i=1; i<=N; i++){
            person[i][0] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        for(int i=1; i<=N; i++){
            person[i][1] = Integer.parseInt(st.nextToken());
        }
        //3. dp 배열 선언 
        int[][] dp = new int [N+1][100];
        //4. 조건에 따라서 dp배열에 값을 저장하고, 이를 활용하여 다음 dp값 구하기=>반복하여 최종 해에 도달달
        for(int i=1; i<=N; i++){
            int lose_health = person[i][0];
            for(int j=0; j<100; j++){
                if(lose_health<=j){
                    dp[i][j] = Integer.max(person[i][1]+dp[i-1][j-lose_health], dp[i-1][j]);
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        //5. 99의 체력(소진할 수 있는 체력 최대치)을 소진한 상태에서 얻을 수 있는 기쁨의 최대값 출력
        System.out.println(dp[N][99]);
    }
}
```
![](https://velog.velcdn.com/images/keumsiun0503/post/fd222aa8-6133-4837-bd35-0607241174d8/image.png)

### 느낀점
>
DP 알고리즘은 학교에서 처음 설명을 들을 때도 상당히 난이도가 있었고, 구현하려고 로직을 생각하기도 까다로운 알고리즘인 것 같다. 또한 완벽하게 이해를 하더라도(그러지 못 했지만) 남에게 잘 설명하는 것은 다른 문제이기 때문에 상당히 힘들었다. DP 알고리즘은 백 번 설명 듣는 것보다 예제 문제를 통해서 DP가 어떤 것인지 파악하는 것이 정말 중요한 것 같다. 나도 DP알고리즘 및 어려운 알고리즘을 계속 풀어나가면서, 이를 어떻게 설명할지 고민하다보면, 나도 보다 더 잘 이해하는 날이 올 것 같다.
